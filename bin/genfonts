#!/usr/bin/env perl
use warnings;
use strict;

our $windows = 0;
our $dryRun = 0;
our $noSave = 0;
our $noTrace = 0;
our $marked = 0;
our $sfdOnly = 0;

use Getopt::Long;
Getopt::Long::Configure('bundling', 'getopt_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'm|marked' => \$marked,
    'w|windows' => \$windows,
    'n|dry-run' => \$dryRun,
    'no-save' => \$noSave,
    'no-trace' => \$noTrace,
    's|sfd-only' => \$sfdOnly,
) or die(":-(");

my $gen = My::FontGenerator->new();
$gen->{specified} = \@ARGV;
$gen->{windows} = $windows;
$gen->{dryRun} = $dryRun;
$gen->generateFonts();

###############################################################################

package My::FontGenerator {
    use warnings;
    use strict;

    use POSIX qw(round);
    use File::Basename qw(basename dirname);
    use File::Path qw(make_path);
    use File::Which qw(which);
    use String::ShellQuote qw(shell_quote);
    use Scalar::Util qw(looks_like_number);

    our $bitmapfont2ttf;
    BEGIN {
        $bitmapfont2ttf = which('bitmapfont2ttf');
        if (!defined $bitmapfont2ttf) {
            die("bitmapfont2ttf: no executable found\n");
        }
    }

    sub new {
        my ($class) = @_;
        my $self = bless({}, $class);
        return $self;
    }

    sub generateFont {
        my ($self, %args) = @_;

        my $source = $args{source};
        my $basename = $args{basename};
        my $familyname = $args{familyname};

        my $pixelSize = $args{pixelSize};
        my $origPixelSize = $args{origPixelSize};

        my @variants;
        if (defined $args{variants}) {
            @variants = grep { m{\S} } split(' ', $args{variants});
        }
        my $bold   = grep { lc $_ eq 'bold' } @variants;
        my $italic = grep { lc $_ eq 'oblique' || lc $_ eq 'italic' } @variants;

        my $weight      = $bold ? 'Bold' : 'Book';
        my $italicAngle = $italic ? -12 : 0;

        my @tags;
        if (defined $args{tags}) {
            @tags = grep { m{\S} } split(' ', $args{tags});
        }

        return if $marked && !$args{marked};

        my $winFix  = $args{winFix};
        my $ascent  = $args{ascent};
        my $descent = $args{descent};

        $ascent  = undef if defined $ascent  && ($ascent  !~ m{\S} || !looks_like_number($ascent));
        $descent = undef if defined $descent && ($descent !~ m{\S} || !looks_like_number($descent));

        my $familynamePrefix = $self->{windows} ? 'XBF WIN ' : 'XBF ';
        $familyname = $familynamePrefix . $familyname;

        my $basenamePrefix = $self->{windows} ? 'XBF-WIN-' : 'XBF-';
        $basename = $basenamePrefix . $basename;

        my $fullname = $familyname;
        my $fontname = $fullname;
        $fontname =~ s{\s+}{}g;

        if (scalar @variants) {
            my $fullnamevariants = join(' ', @variants);
            my $fontnamevariants = $fullnamevariants;
            $fontnamevariants =~ s{\s+}{}g;
            $fullname .= ' ' . $fullnamevariants;
            $fontname .= '-' . $fontnamevariants;
        }

        our @bitmapfont2ttfOptions = ('--monospace');

        if ($self->{windows}) {
            my $px = $pixelSize // $origPixelSize;
            if (defined $px) {
                my $newpx = nearestWinPixelSize($px);
                push(@bitmapfont2ttfOptions, '--new-pixel-size', $newpx);
            }
        }

        push(@bitmapfont2ttfOptions, '--no-save') if $noSave;
        push(@bitmapfont2ttfOptions, '--no-trace') if $noTrace;

        my $ttf;
        my $sfd;
        if ($self->{windows}) {
            $ttf = "fonts/windows/${basename}.ttf";
            $sfd = "sfd/windows/${basename}.sfd";
        } else {
            $ttf = "fonts/macos/${basename}.ttf";
            $sfd = "sfd/macos/${basename}.sfd";
        }

        my @specified = @{$self->{specified} // []};

        if (scalar @specified) {
            return 0 if !tagmatch([@specified], ($source, $basename, $familyname, $fullname, $fontname, $ttf, $sfd, @tags));
        }

        my @dependencies = (
            $0,
            $bitmapfont2ttf,
            dirname($bitmapfont2ttf) . '/../lib/mybdf.py',
            dirname($bitmapfont2ttf) . '/../lib/mybdfchar.py',
            dirname($bitmapfont2ttf) . '/../lib/bitmapfont2ttf.py',
        );

        if (isuptodate([$ttf, $sfd], @dependencies)) {
            printf STDERR ("%s%s and %s are up to date%s\n",
                           "\e[0;32m",
                           $sfd,
                           $ttf,
                           "\e[0m");
            return;
        }

        print STDERR ("\e[0;32m") if -t 2;
        printf STDERR ("Generating %s\n", $sfd);
        printf STDERR ("       and %s...\n", $ttf);
        print STDERR ("\e[0m") if -t 2;
        make_path(dirname($ttf));
        make_path(dirname($sfd));
        my @cmd = (
            'bitmapfont2ttf',
            "--font-name=${fontname}",
            "--full-name=${fullname}",
            "--family-name=${familyname}",
            "--italic-angle=${italicAngle}",
            "--weight=${weight}",
            @bitmapfont2ttfOptions,
            $source,
            ($sfdOnly ? ($sfd) : ($sfd, $ttf)),
        );
        if ($self->{dryRun}) {
            print(shell_quote(@cmd), "\n");
        } else {
            warn("+ ", shell_quote(@cmd), "\n");
            system(@cmd) and exit(1);
        }
    }

    sub generateFonts {
        my ($self) = @_;
        my $filename = dirname($0) . '/genfonts.txt';
        my $fh;
        if (!open($fh, '<', $filename)) {
            warn("$filename: $!\n");
            return;
        }
        my $header = <$fh>;
        my $junk = <$fh>;
        $header =~ s{\R\z}{};
        $header =~ s{^\s*\|\s*}{};
        $header =~ s{\s*\|\s*$}{};
        my @header = split(/\s*\|\s*/, $header);
        while (<$fh>) {
            next if !m{^\|};
            s{\R\z}{};
            s{^\s*\|\s*}{};
            s{\s*\|\s*$}{};
            my @data = split(/\s*\|\s*/, $_);
            @data = map { $_ eq '' ? undef : $_ } @data;
            my %row;
            for (my $i = 0; $i < scalar @header && $i < scalar @data; $i += 1) {
                $row{$header[$i]} = $data[$i];
            }
            printf("A %s  B %s\n", $row{origPixelSize} // '-',
                   $row{pixelSize} // '-');
            $self->generateFont(%row);
        }
    }

    sub isuptodate {
        my ($target, @dependencies) = @_;
        if (ref $target eq 'ARRAY') {
            foreach my $subtarget (@$target) {
                return 0 if !isuptodate($subtarget, @dependencies);
            }
            return 1;
        }
        return 0 if !-e $target;
        my $targetage = -M $target;
        return 0 if grep { $targetage > -M $_ } @dependencies;
        return 1;
    }

    sub tagmatch {
        my ($specified, @tags) = @_;
        if (ref $specified eq 'ARRAY') {
            return (grep { tagmatch($_, @tags) } @$specified) ? 1 : 0;
        }
        return (grep { $specified eq $_ } @tags) ? 1 : 0;
    }

    sub nearestWinPixelSize {
        my ($px) = @_;
        my @fs = (6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72);
        @fs = map { round($_ * 4 / 3) } @fs;
        @fs = grep { $_ >= $px } @fs;
        print("$px => $fs[0]\n");
        return $fs[0] if scalar @fs;
        return $px;
    }
};
